use crate::lexer;

use kind_tree::concrete::*;
use kind_span::{Symbol, Span};

use thin_vec::thin_vec;
use thin_vec::ThinVec;
use num_bigint::BigUint;

grammar;

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token {
        "(" => lexer::Token::LPar,
        ")" => lexer::Token::RPar,
        "[" => lexer::Token::LBracket,
        "]" => lexer::Token::RBracket,
        "{" => lexer::Token::LBrace,
        "}" => lexer::Token::RBrace,
        "=" => lexer::Token::Eq,
        ":" => lexer::Token::Colon,
        ";" => lexer::Token::Semi,
        "=>" => lexer::Token::FatArrow,
        "$" => lexer::Token::Dollar,
        "," => lexer::Token::Comma,
        "->" => lexer::Token::RightArrow,
        ".." => lexer::Token::DotDot,
        "." => lexer::Token::Dot,
        "~" => lexer::Token::Tilde,
        "::" => lexer::Token::ColonColon,

        "do" => lexer::Token::Do,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,
        "match" => lexer::Token::Match,
        "open" => lexer::Token::Open,
        "let" => lexer::Token::Let,
        "type" => lexer::Token::Type,
        "record" => lexer::Token::Record,
        "constructor" => lexer::Token::Constructor,
        "impossible" => lexer::Token::Impossible,
        "use" => lexer::Token::Use,
        "as" => lexer::Token::As,
        "return" => lexer::Token::Return,
        "ask" => lexer::Token::Ask,
        "with" => lexer::Token::With,

        "specialize" => lexer::Token::Specialize,
        "into" => lexer::Token::Into,
        "in" => lexer::Token::In,

        help => lexer::Token::Help(<String>),
        char => lexer::Token::Char(<char>),
        str => lexer::Token::Str(<String>),
        "+" => lexer::Token::Plus,
        "-" => lexer::Token::Minus,
        "/" => lexer::Token::Slash,
        "<<" => lexer::Token::LessLess,
        "*" => lexer::Token::Star,
        ">>" => lexer::Token::GreaterGreater,
        "%" => lexer::Token::Percent,
        "&" => lexer::Token::Ampersand,
        "|" => lexer::Token::Bar,
        "^" => lexer::Token::Hat,
        "<" => lexer::Token::Less,
        "<=" => lexer::Token::LessEq,
        "==" => lexer::Token::EqEq,
        ">=" => lexer::Token::GreaterEq,
        ">" => lexer::Token::Greater,
        "!=" => lexer::Token::BangEq,
        "!" => lexer::Token::Bang,
        "+=" => lexer::Token::PlusEq,
        "@=" => lexer::Token::AtEq,
        "##" => lexer::Token::HashHash,
        "#" => lexer::Token::Hash,
        lower_id => lexer::Token::LowerId(<String>),
        upper_id => lexer::Token::UpperId(<String>),
        doc      => lexer::Token::DocComment(<String>),
        num60 => lexer::Token::Num60(<u64>),
        num120 => lexer::Token::Num120(<u128>),
        nat => lexer::Token::Nat(<BigUint>),
        float => lexer::Token::Float(<f64>),
        typeu60 => lexer::Token::U60,
        typef60 => lexer::Token::F60,
        U => lexer::Token::U,
    }
}

Comma<T>: ThinVec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v.into(),
        Some(e) => {
            v.push(e);
            v.into()
        }
    }
};

Comma1<T>: ThinVec<T> = {
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        v.into()
    }
};

Semi<T>: ThinVec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v.into(),
        Some(e) => {
            v.push(e);
            v.into()
        }
    }
};

Semi1<T>: ThinVec<T> = {
    <mut v:(<T> ";")*> <e:T> => {
        v.push(e);
        v.into()
    }
};

Attribute: Attribute = { Item<AttributeKind> }

Box<T>: Box<T> = {
    <e:T> => Box::new(e)
};

Item<T> : Item<T> = {
    <s: @L> <data: T> <e: @L> => Item {
        span: Span(s..e),
        data
    }
}

Erasable<T> : Erasable<T> = {
    "~" <data: T> => Erasable::new(data, Erased::Yes),
    <data: T>     => Erasable::new(data, Erased::No),
}

// Identifiers

AnyIdent : Item<Symbol> = {
    <fst: Item<lower_id>> => fst.map(|x| Symbol(x)),
    <fst: Item<upper_id>> => fst.map(|x| Symbol(x)),
}

UpperId : Item<Symbol> = {
    <fst: Item<upper_id>> => fst.map(|x| Symbol(x)),
}

LowerId : Item<Symbol> = {
    <fst: Item<lower_id>> => fst.map(|x| Symbol(x)),
}

QualifiedIdentInner : ThinVec<Item<Symbol>> = {
    <fst: UpperId> <rest: ("." <AnyIdent>)*> => {
        let mut vec = thin_vec![fst];
        vec.extend(rest);
        vec
    }
}

QualifiedIdent : QualifiedIdent = {
    <data: Item<QualifiedIdentInner>> => QualifiedIdent { data }
}

Ident : Ident = {
    <data: LowerId> => data
}

// Attributes

AttributeStyle : AttributeStyle = {
    <str: str>                           => AttributeStyle::String(Symbol(str)),
    <num: num60>                         => AttributeStyle::Number(num),
    <id: Ident>                          => AttributeStyle::Identifier(id),
    "[" <ids: Comma<AttributeStyle>> "]" => AttributeStyle::List(ids.into()),
}

AttributeKind : AttributeKind = {
    "#" <name: Ident> <args: ("(" <Comma<AttributeStyle>> ")")?> <value: ("=" <AttributeStyle>)?> => {
        AttributeKind {
            name,
            arguments: args.unwrap_or_default(),
            value
        }
    }
}

// Literal

LiteralKind : LiteralKind = {
    U             => LiteralKind::Type,
    <h: help>     => LiteralKind::Help(Symbol(h)),
    typeu60       => LiteralKind::NumTypeU60,
    typef60       => LiteralKind::NumTypeF60,
    <num: num60>  => LiteralKind::NumU60(num),
    <num: num120> => LiteralKind::NumU120(num),
    <abs: float>  => LiteralKind::NumF60(abs),
    <nat: nat>    => LiteralKind::Nat(nat),
    <str: str>    => LiteralKind::String(Symbol(str)),
}

// Atoms

Operator : OperatorKind = {
    "+"  => OperatorKind::Add,
    "-"  => OperatorKind::Sub,
    "*"  => OperatorKind::Mul,
    "/"  => OperatorKind::Div,
    "%"  => OperatorKind::Mod,
    "&"  => OperatorKind::And,
    "|"  => OperatorKind::Or,
    "^"  => OperatorKind::Xor,
    "<<" => OperatorKind::Shl,
    ">>" => OperatorKind::Shr,
    "<"  => OperatorKind::Ltn,
    "<=" => OperatorKind::Lte,
    "==" => OperatorKind::Eql,
    ">=" => OperatorKind::Gte,
    ">"  => OperatorKind::Gtn,
    "!=" => OperatorKind::Neq,
}

MultiCall : ExprKind = {
    <expr: Expr> => expr.data,
    <operator: Operator> <left: Atom> <right: Atom> => ExprKind::Binary (BinaryNode {
        operator,
        left: Box::new(left),
        right: Box::new(right)
    }),
    <expr: Expr> <exprs: (";" <Erasable<Atom>>)+> => ExprKind::App (AppNode {
        fun: Box::new(expr),
        args: exprs.into(),
    }),
}

AtomKind : ExprKind = {
    <lit: LiteralKind>   => ExprKind::Lit(lit),
    "(" <expr: Item<MultiCall>> ")" => ExprKind::Paren(Box::new(expr)),
}

Atom : Expr = { <expr: Item<AtomKind>> => expr }

// Exprs

VarNode : VarNode = {
    <name: Ident> => VarNode { name }
}

AppNode : AppNode = {
    <fun: Atom> <args: Erasable<Atom>*> => {
        AppNode { fun: Box::new(fun), args: args.into() }
    }
}

AllNode : AllNode = {
    "(" <param: Erasable<LowerId>> ":" <typ: Expr>  ")" "->" <body: Expr> => {
        AllNode { param: Some(param.data), typ: Box::new(Erasable {
            data: typ,
            erased: param.erased
        }), body: Box::new(body) }
    }
}

SigmaNode : SigmaNode = {
    "[" <param: LowerId> ":" <typ: Expr>  "]" "->" <body: Expr> => SigmaNode { param: Some(param), typ: Box::new(typ), body: Box::new(body) }
}

LambdaNode : LambdaNode = {
    "(" <param: Erasable<LowerId>> ":" <typ: Expr>  ")" "=>" <body: Expr> => LambdaNode { param: param, typ: Some(Box::new(typ)), body: Box::new(body) }
}

LetNode : LetNode = {
    "let" <param: LowerId> "=" <body: Expr> ";" <next: Expr> => LetNode {
        param,
        body: Box::new(body),
        next: Box::new(next)
    }
}

PairNode<T> : PairNode<T> = {
    "$" <left: T> <right: T> => PairNode { left: Box::new(left), right: Box::new(right) }
}

ListNode<T> : ListNode<T> = {
    "[" <exprs: Comma<T>> "]" => ListNode { elements: exprs.into() }
}

SubstNode : SubstNode = {
    "specialize" <name: LowerId> "into" <redx: num60> "in" <expr: Expr> => {
        SubstNode {
            name,
            redx,
            expr: Box::new(expr)
        }
    }
}

DoNode : DoNode = {
    "do" <typ: QualifiedIdent> "{" <sttm: Sttm> "}" => DoNode {
        typ,
        sttm
    }
}

IfNode : IfNode = {
    "if" <cond: Expr> ";"? "{" ";"? <if_: Expr> "}" ";"? "else" ";"? "{" <else_: Expr> "}" => IfNode {
        cond: Box::new(cond),
        if_: Box::new(if_),
        else_: Box::new(else_),
    }
}

WithVar : (Ident, Option<Box<Expr>>) = {
    <name: LowerId>                                => (name, None),
    "(" <name: LowerId> ":" <expr: Box<Expr>> ")" => (name, Some(expr)),
}

Rename : Rename = {
    "(" <field: LowerId> ":" <to: LowerId> ")" => Rename::Named { field, to },
    <name: LowerId> => Rename::Unnamed(name)
}

Case : Case = {
    <constructor: LowerId> <bindings: Rename*> "=>" <value: Box<Expr>> => Case { constructor, bindings: bindings.into(), value }
}

MatchNode : MatchNode = {
    "match"
        <typ: QualifiedIdent> <scrutinee: Box<Expr>>
        <value: ("=" <Box<Expr>>)?>
        <with_vars: ("with" <WithVar*>)?>
        "{" ";"? <cases: Semi<Case>> "}"
        <motive: (":" <Box<Expr>>)?>
        => MatchNode {
            typ,
            scrutinee,
            value,
            with_vars: with_vars.unwrap_or_default().into(),
            cases,
            motive
        },
}

OpenNode : OpenNode = {
    "open" <type_name: QualifiedIdent> <scrutinee: Box<Atom>> <motive: (":" <Box<Expr>>)?> ";" <next: Box<Expr>> =>
        OpenNode {
            type_name,
            scrutinee,
            motive,
            next,
        }
}

MolKind : ExprKind = {
    <all: AllNode>         => ExprKind::All(all),
    <sigma: SigmaNode>     => ExprKind::Sigma(sigma),
    <lambda: LambdaNode>   => ExprKind::Lambda(lambda),
    <letn: LetNode>        => ExprKind::Let(letn),
    <pair: PairNode<Atom>> => ExprKind::Pair(pair),
    <list: ListNode<Expr>> => ExprKind::List(list),
    <subst: SubstNode>     => ExprKind::Subst(subst),
    <don: DoNode>          => ExprKind::Do(don),

    <ifn: IfNode>       => ExprKind::If(ifn),
    //<matchn: MatchNode> => ExprKind::Match(matchn),
    <open: OpenNode>    => ExprKind::Open(open),

    //<access: AccessNode> => ExprKind::Access(access),

    <app: AppNode> => {
        if app.args.is_empty() {
            app.fun.data
        } else {
            ExprKind::App(app)
        }
    },
}

Mol : Expr = { <expr:Item<MolKind>> => expr }

AllNodeTrim : AllNode = {
    <typ: Erasable<Mol>> "->" <body: Expr> => AllNode { param: None, typ: Box::new(typ), body: Box::new(body) }
}

AnnNode : AnnNode = {
    <expr: Mol> "::" <typ: Expr> => AnnNode { expr: Box::new(expr), typ: Box::new(typ) }
}

LambdaNodeTrim : LambdaNode = {
    <param: Erasable<Ident>> "=>" <body: Box<Expr>> => LambdaNode {
            param,
            typ: None,
            body
        },
}

ExprKind : ExprKind = {
    //<all: AllNodeTrim>    => ExprKind::All(all),
    //<ann: AnnNode>        => ExprKind::Ann(ann),
    <lam: LambdaNodeTrim> => ExprKind::Lambda(lam),
    <expr: MolKind>       => expr
}

Expr : Expr = { <expr:Item<ExprKind>> => expr }

// Statement

SttmKind : SttmKind = {
    "return" <expr: Expr> => SttmKind::Return(Box::new(expr)),
    // <expr: Expr> => SttmKind::RetExpr(Box::new(expr)),
    // "ask" <expr: Expr> ";" <sttm: Sttm> => SttmKind::Expr(Box::new(expr), Box::new(sttm)),
    "ask" <id: LowerId> "=" <expr: Expr> ";" <sttm: Sttm> => SttmKind::Ask(id, Box::new(expr), Box::new(sttm)),
    "let" <id: LowerId> "=" <expr: Expr> ";" <sttm: Sttm> => SttmKind::Let(id, Box::new(expr), Box::new(sttm)),
}

Sttm : Sttm = { <sttm: Item<SttmKind>> => sttm }

// Types and Definitions

PatAtomKind : PatKind = {
    <num: num60>           => PatKind::U60(num),
    <num: num120>          => PatKind::U120(num),
    <abs: float>           => PatKind::F60(abs),
    <nat: nat>             => PatKind::Nat(nat),
    <str: str>             => PatKind::Str(Symbol(str)),
    <char: char>           => PatKind::Char(char),
    <list: ListNode<Pat>>  => PatKind::List(list),
    "(" <e: Box<Pat>> ")"  => PatKind::Paren(e),
}

PatAtom = { Item<PatAtomKind> }

PatKind : PatKind = {
    <fun: QualifiedIdent> <pats: Box<Pat>*> => PatKind::App(fun, pats),
    <var: VarNode>        => PatKind::Var(var),
    <pair: PairNode<Pat>> => PatKind::Pair(pair),
    "(" ")"               => PatKind::Absurd,
}

Pat : Pat = { Item<PatKind> }

RecordDecl : RecordDecl = {

}

SumDecl : SumDecl = {

}

RuleRHS : RuleRHS = {
    "=" <expr: Box<Expr>> => RuleRHS::Value(expr),
    "impossible"          => RuleRHS::Impossible
}

Rule : Rule = {
    <name: QualifiedIdent> <pats: Box<Pat>*> <body: RuleRHS> => {
        Rule {
            name,
            pats,
            body
        }
    }
}

ArgumentKind : ArgumentKind = {
    "-"? <keep: "+"?> "<" <name: Ident> <typ: (":" <Box<Expr>>)?> ">" => {
        let erased = !keep.is_some();
        ArgumentKind {
            hidden: true,
            erased,
            name,
            typ
        }
    },
    <erased: "-"?> <keep: "+"?> "(" <name: Ident> <typ: (":" <Box<Expr>>)?> ")" => {
        let erased = erased.is_some();
        ArgumentKind {
            hidden: false,
            erased,
            name,
            typ
        }
    },
}

Argument : Argument = { Item<ArgumentKind> }

Signature : Signature = {
    <name: QualifiedIdent> <args: Argument*> ".." <typ: Box<Expr>> => {
        Signature {
            name,
            args: args.into(),
            typ
        }
    }
}

Function : Function = {

}

TopLevelKind : TopLevelKind = {
    <rule: Rule> => TopLevelKind::Rule(rule),
}

TopLevel : TopLevel = {
    <doc: (<doc> ";"?)*> <attrs: (<Attribute> ";"?)*> <data: Item<TopLevelKind>> => {
        TopLevel {
            docs: doc.into(),
            attrs: attrs.into(),
            data
        }
    }
}

Module : Module = {
    <declarations: TopLevel> ";"? => Module { declarations: thin_vec![declarations] },
}