Main = API.check_all

// Prelude
// -------

// U60.if -(r: Type) U60 r r : r
(U60.if 0 then else) = else
(U60.if 1 then else) = then

// U60.equal U60 U60 : Bool
(U60.equal a b) = (U60.if (== a b) True False)

// U60.max U60 U60 : Bool
(U60.max a b) = (U60.if (> a b) a b)

// Name.length Name : U60
(Name.length name) = (String.length (Show.name name))

// If -(r: Type) Bool r r : r
(Bool.if False then else) = else
(Bool.if True  then else) = then

// Bool.and Bool Bool : Bool
(Bool.and True  b) = b
(Bool.and False b) = False

// Bool.or Bool Bool : Bool
(Bool.or True  b) = True
(Bool.or False b) = b

// Maybe.case -(a: Type) -(r: Type) (Maybe a) r (a -> r) : r
(Maybe.case None       none some) = none
(Maybe.case (Some val) none some) = (some val)

// Maybe.bind -(a: Type) -(b: Type) (Maybe a) : (a -> (Maybe b)) (Maybe b)
(Maybe.bind None)     = @cont None
(Maybe.bind (Some x)) = @cont (cont x)

// Maybe.try
(Maybe.try List.nil                  df) = df
(Maybe.try (List.cons (Some x) rest) df) = x
(Maybe.try (List.cons None     rest) df) = (Maybe.try rest df)

// List.at -(a: Type) (List a) U60 : (Maybe a)
(List.at (List.cons x xs) 0) = (Some x)
(List.at (List.cons x xs) n) = (List.at xs (- n 1))
(List.at List.nil         n) = None

// List.tail -(a: Type) (List a) : (List a)
(List.tail (List.cons x xs)) = xs
(List.tail List.nil)         = List.nil

// List.reverse -(a: Type) (List a) : (List a)
(List.reverse xs) = (List.reverse.go xs [])

// List.reverse.go -(a: Type) (List a) (List a) : (List a)
(List.reverse.go List.nil         res) = res
(List.reverse.go (List.cons x xs) res) = (List.reverse.go xs (List.cons x res))

// List.join (str: (List String)) (sep: String) : String
(List.join list sep) = (List.join.go list sep True)

// List.join.go (str: (List String)) (sep: String) (fst: Bool) : String
(List.join.go (List.cons head tail) sep fst) = (Text [(Bool.if fst "" sep) head (List.join.go tail sep False)])
(List.join.go List.nil              sep fst) = String.nil

// List.append -(a: Type) (val: a) (list: List a) : List a
(List.append List.nil         val) = (List.cons val List.nil)
(List.append (List.cons x xs) val) = (List.cons x (List.append xs val))

// String.cut String : String
(String.cut str) = (String.cut.go str "(...)" 2048)

// String.cut.go String String String : String
(String.cut.go String.nil         df n) = String.nil
(String.cut.go (String.cons x xs) df 0) = df
(String.cut.go (String.cons x xs) df n) = (String.cons x (String.cut.go xs df (- n 1)))

// String.concat String String : String
(String.concat String.nil         ys) = ys
(String.concat (String.cons x xs) ys) = (String.cons x (String.concat xs ys))

// String.is_empty String : Bool
(String.is_empty String.nil) = True
(String.is_empty other)      = False

// String.length String : U60
(String.length String.nil)         = 0
(String.length (String.cons x xs)) = (+ 1 (String.length xs))

// String.pad_right (str: String) (chr: U60) (len: U60) : String
(String.pad_right str                chr 0)   = String.nil
(String.pad_right (String.cons x xs) chr len) = (String.cons x   (String.pad_right xs         chr (- len 1)))
(String.pad_right String.nil         chr len) = (String.cons chr (String.pad_right String.nil chr (- len 1)))

// Text (List String) : String
(Text List.nil)         = String.nil
(Text (List.cons x xs)) = (String.concat x (Text xs))

// Color String : String
(Color x) = (Text [ (String.cons 27 String.nil) "[" x "m" ])

// Line : String
Line = (String.cons 10 String.nil)

// Subst
// -----

// type Subst {
//    (End)                            // end of subst list
//    (Unf (rest: Subst))              // unfilled hole
//    (Sub (term: Term) (rest: Subst)) // subst hole
// }

// Subst.look Subst U60 : (Maybe Term)
(Subst.look End             0) = None
(Subst.look (Unf rest)      0) = None
(Subst.look (Sub term rest) 0) = (Some term)
(Subst.look End             n) = None
(Subst.look (Unf rest)      n) = (Subst.look rest (- n 1))
(Subst.look (Sub term rest) n) = (Subst.look rest (- n 1))

// Subst.fill Subst U60 Term : Subst
(Subst.fill End             0 term) = (Sub term End)
(Subst.fill (Unf rest)      0 term) = (Sub term rest)
(Subst.fill (Sub lost rest) 0 term) = (Sub term rest)
(Subst.fill End             n term) = (Unf (Subst.fill End  (- n 1) term))
(Subst.fill (Unf rest)      n term) = (Unf (Subst.fill rest (- n 1) term))
(Subst.fill (Sub keep rest) n term) = (Sub keep (Subst.fill rest (- n 1) term))

// Context
// -------

// type Context {
//   Empty : Context
//   (Entry (name: U60) (type: Term) (vals: (List Term))) : Context
// }

// Context.extend U60 Term (List Term) : Context
(Context.extend (Entry name type vals rest) n t v) = (Entry name type vals (Context.extend rest n t v))
(Context.extend Empty                       n t v) = (Entry n t v Empty)

// Context.add_value Context U60 Term : Context
(Context.add_value (Entry name type vals rest) 0 val) = (Entry name type (List.cons val vals) rest)
(Context.add_value (Entry name type vals rest) n val) = (Entry name type vals (Context.add_value rest (- n 1) val))
(Context.add_value Empty                       n val) = Empty

// Context.find -(r: Type) Context U60 r (U60 -> Term -> (List Term) -> r) : r
(Context.find (Entry name type vals rest) 0 d f) = (f name type vals)
(Context.find (Entry name type vals rest) i d f) = (Context.find rest (- i 1) d f)
(Context.find Empty                       i d f) = d

// Context.shrink Context : Context
(Context.shrink Empty)                        = Empty // FIXME: can't move to last line; investigate
(Context.shrink (Entry name type vals Empty)) = Empty
(Context.shrink (Entry name type vals rest))  = (Entry name type vals (Context.shrink rest))

// Context.is_empty Context : Context
(Context.is_empty (Entry name type vals rest)) = False
(Context.is_empty Empty)                       = True

// Context.max_name_length Context : U60
(Context.max_name_length Empty) = 0
(Context.max_name_length (Entry name type vals rest)) =
  (U60.max (Name.length name) (Context.max_name_length rest))

// Checker Monad
// -------------

// type Result (a : Type) {
//   (Checked (ctx: Context) (dep: U60) (rhs: Bool) (sub: Subst) (eqt: List Equation) (err: List Error) (ret: a))
//   (Errored (ctx: Context) (sub: Subst) (err: List Error))
// }

// Checker (a : Type) : Type {
//   (context         : Context)
//   (depth           : U60)
//   (right_hand_side : Bool)
//   (substitutions   : Subst)
//   (equations       : List Equation)
//   (errors          : List Error)
//   (Result a)
// }

// Checker.bind -(a: Type) -(b: Type) (Checker a) : (a -> Checker b) (Checker b)
(Checker.bind checker) = λnext λctx λdep λrhs λsub λeqt λerr ((Checker.bind.result (checker ctx dep rhs sub eqt err)) next)

// Checker.bind.result -(a: Type) -(b: Type) (Result a) : (a -> Checker b) (Result b)
(Checker.bind.result (Checked ctx dep rhs sub eqt err val)) = λnext (next val ctx dep rhs sub eqt err)
(Checker.bind.result (Errored ctx sub err))                 = λnext (Errored ctx sub err)

// Checker.done -(a: Type) (x: a) : (Checker a)
(Checker.done val) = λctx λdep λrhs λsub λeqt λerr (Checked ctx dep rhs sub eqt err val)

// Checker.error -(a: Type) (ret: a) (err: Error) : (Checker a)
(Checker.error ret new_err) = λctx λdep λrhs λsub λeqt λerr (Checked ctx dep rhs sub eqt (List.append err new_err) ret)

// Checker.fail -(a: Type) (err: Error) : (Checker a)
(Checker.fail new_err) = λctx λdep λrhs λsub λeqt λerr (Errored ctx sub (List.cons new_err err))

// Checker.run -(a: Type) (Checker a) (rhs: Bool) : (Result a)
(Checker.run chk rhs) = (chk Empty 0 rhs End List.nil List.nil)

// Checker.get_context : (Checker Context)
(Checker.get_context) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs sub eqt err ctx)

// Checker.get_depth : (Checker U60)
(Checker.get_depth) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs sub eqt err dep)

// Checker.get_subst : (Checker Subst)
(Checker.get_subst) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs sub eqt err sub)

// Checker.new_equation (orig: U60) (a: Term) (b: Term) : (Checker Unit)
(Checker.new_equation orig a b) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs sub (List.append eqt (Equation ctx orig a b)) err Unit.new)

// Checker.get_equations : (Checker (List (Pair Term Term)))
(Checker.get_equations) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs sub eqt err eqt)

// Checker.get_errors : (Checker (List Error))
(Checker.get_errors) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs sub eqt err err)

// Checker.get_right_hand_side : (Checker U60)
(Checker.get_right_hand_side) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs sub eqt err rhs)

// Checker.set_right_hand_side Bool : (Checker Unit)
(Checker.set_right_hand_side rhs) = λctx λdep λold_rhs λsub λeqt λerr
  (Checked ctx dep rhs sub eqt err Unit.new)

// Checker.extend U60 Term (List Term) : (Checker Unit)
(Checker.extend name type vals) = λctx λdep λrhs λsub λeqt λerr
  (Checked (Context.extend ctx name type vals) (+ dep 1) rhs sub eqt err Unit)

// Checker.shrink : (Checker Unit)
(Checker.shrink) = λctx λdep λrhs λsub λeqt λerr
  (Checked (Context.shrink ctx) (- dep 1) rhs sub eqt err Unit.new)

// Checker.extended -(a: Type) (Checker a) U60 Term Term : (Checker a)
(Checker.extended checker name type vals) = 
  ask (Checker.bind (Checker.extend name type vals))
  ask got = (Checker.bind checker)
  ask (Checker.bind Checker.shrink)
  (Checker.done got)

// Checker.find -(r: Type) U60 r (U60 -> Term -> (List Term) -> r) : (Checker r)
(Checker.find idx d f) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs sub eqt err (Context.find ctx idx d f))

// Checker.add_value (idx: U60) (val: Term) : (Checker Unit)
(Checker.add_value idx val) = λctx λdep λrhs λsub λeqt λerr
  (Checked (Context.add_value ctx idx val) dep rhs sub eqt err Unit.new)

// Checker.fill (idx: U60) (val: Term) : (Checker Unit)
(Checker.fill idx val) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs (Subst.fill sub idx val) eqt err Unit.new)

// Checker.look (idx: U60) : (Checker (Maybe Term))
(Checker.look idx) = λctx λdep λrhs λsub λeqt λerr
  (Checked ctx dep rhs sub eqt err (Subst.look sub idx))

// Term utils
// ----------

// Term.if_all -(r: Type) Term (U60 U60 -> Term -> (Term -> Term) -> r) r : r
(Term.if_all (All orig name type body) then else) = (then orig name type body)
(Term.if_all other                     then else) = else

// Term.orig
(Term.get_origin (Typ orig) got)                      = (got orig (Typ orig))
(Term.get_origin (Var orig name index) got)           = (got orig (Var orig name index))
(Term.get_origin (Hol orig numb) got)                 = (got orig (Hol orig numb))
(Term.get_origin (All orig name type body) got)       = (got orig (All orig name type body))
(Term.get_origin (Lam orig name body) got)            = (got orig (Lam orig name body))
(Term.get_origin (App orig func argm) got)            = (got orig (App orig func argm))
(Term.get_origin (Let orig name expr body) got)       = (got orig (Let orig name expr body))
(Term.get_origin (Ann orig expr type) got)            = (got orig (Ann orig expr type))
(Term.get_origin (Ct0 name orig) got)                 = (got orig (Ct0 name orig))
(Term.get_origin (Ct1 name orig a) got)               = (got orig (Ct1 name orig a))
(Term.get_origin (Ct2 name orig a b) got)             = (got orig (Ct2 name orig a b))
(Term.get_origin (Ct3 name orig a b c) got)           = (got orig (Ct3 name orig a b c))
(Term.get_origin (Ct4 name orig a b c d) got)         = (got orig (Ct4 name orig a b c d))
(Term.get_origin (Ct5 name orig a b c d e) got)       = (got orig (Ct5 name orig a b c d e))
(Term.get_origin (Ct6 name orig a b c d e f) got)     = (got orig (Ct6 name orig a b c d e f))
(Term.get_origin (Ct7 name orig a b c d e f g) got)   = (got orig (Ct7 name orig a b c d e f g))
(Term.get_origin (Ct8 name orig a b c d e f g h) got) = (got orig (Ct8 name orig a b c d e f g h))
(Term.get_origin (Fn0 name orig) got)                 = (got orig (Fn0 name orig))
(Term.get_origin (Fn1 name orig a) got)               = (got orig (Fn1 name orig a))
(Term.get_origin (Fn2 name orig a b) got)             = (got orig (Fn2 name orig a b))
(Term.get_origin (Fn3 name orig a b c) got)           = (got orig (Fn3 name orig a b c))
(Term.get_origin (Fn4 name orig a b c d) got)         = (got orig (Fn4 name orig a b c d))
(Term.get_origin (Fn5 name orig a b c d e) got)       = (got orig (Fn5 name orig a b c d e))
(Term.get_origin (Fn6 name orig a b c d e f) got)     = (got orig (Fn6 name orig a b c d e f))
(Term.get_origin (Fn7 name orig a b c d e f g) got)   = (got orig (Fn7 name orig a b c d e f g))
(Term.get_origin (Fn8 name orig a b c d e f g h) got) = (got orig (Fn8 name orig a b c d e f g h))
(Term.get_origin (Hlp orig) got)                      = (got orig (Hlp orig))
(Term.get_origin (U60 orig) got)                      = (got orig (U60 orig))
(Term.get_origin (Num orig numb) got)                 = (got orig (Num orig numb))
(Term.get_origin (Op2 orig oper val0 val1) got)       = (got orig (Op2 orig oper val0 val1))

// Term.set_origin
(Term.set_origin new_orig (Typ orig))                      = (Typ new_orig)
(Term.set_origin new_orig (Var orig name index))           = (Var new_orig name index)
(Term.set_origin new_orig (Hol orig numb))                 = (Hol new_orig numb)
(Term.set_origin new_orig (All orig name type body))       = (All new_orig name type body)
(Term.set_origin new_orig (Lam orig name body))            = (Lam new_orig name body)
(Term.set_origin new_orig (App orig func argm))            = (App new_orig func argm)
(Term.set_origin new_orig (Let orig name expr body))       = (Let new_orig name expr body)
(Term.set_origin new_orig (Ann orig expr type))            = (Ann new_orig expr type)
(Term.set_origin new_orig (Ct0 name orig))                 = (Ct0 name new_orig)
(Term.set_origin new_orig (Ct1 name orig a))               = (Ct1 name new_orig a)
(Term.set_origin new_orig (Ct2 name orig a b))             = (Ct2 name new_orig a b)
(Term.set_origin new_orig (Ct3 name orig a b c))           = (Ct3 name new_orig a b c)
(Term.set_origin new_orig (Ct4 name orig a b c d))         = (Ct4 name new_orig a b c d)
(Term.set_origin new_orig (Ct5 name orig a b c d e))       = (Ct5 name new_orig a b c d e)
(Term.set_origin new_orig (Ct6 name orig a b c d e f))     = (Ct6 name new_orig a b c d e f)
(Term.set_origin new_orig (Ct7 name orig a b c d e f g))   = (Ct7 name new_orig a b c d e f g)
(Term.set_origin new_orig (Ct8 name orig a b c d e f g h)) = (Ct8 name new_orig a b c d e f g h)
(Term.set_origin new_orig (Fn0 name orig))                 = (Fn0 name new_orig)
(Term.set_origin new_orig (Fn1 name orig a))               = (Fn1 name new_orig a)
(Term.set_origin new_orig (Fn2 name orig a b))             = (Fn2 name new_orig a b)
(Term.set_origin new_orig (Fn3 name orig a b c))           = (Fn3 name new_orig a b c)
(Term.set_origin new_orig (Fn4 name orig a b c d))         = (Fn4 name new_orig a b c d)
(Term.set_origin new_orig (Fn5 name orig a b c d e))       = (Fn5 name new_orig a b c d e)
(Term.set_origin new_orig (Fn6 name orig a b c d e f))     = (Fn6 name new_orig a b c d e f)
(Term.set_origin new_orig (Fn7 name orig a b c d e f g))   = (Fn7 name new_orig a b c d e f g)
(Term.set_origin new_orig (Fn8 name orig a b c d e f g h)) = (Fn8 name new_orig a b c d e f g h)
(Term.set_origin new_orig (Hlp orig))                      = (Hlp new_orig)
(Term.set_origin new_orig (U60 orig))                      = (U60 new_orig)
(Term.set_origin new_orig (Num orig numb))                 = (Num new_orig numb)
(Term.set_origin new_orig (Op2 orig oper val0 val1))       = (Op2 new_orig oper val0 val1)

// SO = Term.set_origin
(SO new_orig term) = (Term.set_origin new_orig term)

// Term.fillable Term Subst : Bool
// -------------------------------

(Term.fillable term End) =
  False

(Term.fillable (Typ orig) sub) =
  False

(Term.fillable (Var orig name index) sub) =
  False

(Term.fillable (All orig name type body) sub) =
  let type = (Term.fillable type sub)
  let body = (Term.fillable (body (Hlp 0)) sub)
  (Bool.or type body)

(Term.fillable (Lam orig name body) sub) =
  let body = (Term.fillable (body (Hlp 0)) sub)
  body

(Term.fillable (App orig func argm) sub) =
  let func = (Term.fillable func sub)
  let argm = (Term.fillable argm sub)
  (Bool.or func argm)

(Term.fillable (Let orig name expr body) sub) =
  let expr = (Term.fillable expr sub)
  let body = (Term.fillable (body (Hlp 0)) sub)
  (Bool.or expr body)

(Term.fillable (Ann orig expr type) sub) =
  let expr = (Term.fillable expr sub)
  let type = (Term.fillable type sub)
  (Bool.or expr type)

(Term.fillable (Ct0 name orig) sub) =
  False

(Term.fillable (Ct1 name orig a) sub) =
  let a = (Term.fillable a sub)
  a

(Term.fillable (Ct2 name orig a b) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  (Bool.or a b)

(Term.fillable (Ct3 name orig a b c) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  (Bool.or a (Bool.or b c))

(Term.fillable (Ct4 name orig a b c d) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  (Bool.or a (Bool.or b (Bool.or c d)))

(Term.fillable (Ct5 name orig a b c d e) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  let e = (Term.fillable e sub)
  (Bool.or a (Bool.or b (Bool.or c (Bool.or d e))))

(Term.fillable (Ct6 name orig a b c d e f) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  let e = (Term.fillable e sub)
  let f = (Term.fillable f sub)
  (Bool.or a (Bool.or b (Bool.or c (Bool.or d (Bool.or e f)))))

(Term.fillable (Ct7 name orig a b c d e f g) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  let e = (Term.fillable e sub)
  let f = (Term.fillable f sub)
  let g = (Term.fillable g sub)
  (Bool.or a (Bool.or b (Bool.or c (Bool.or d (Bool.or e (Bool.or f g))))))

(Term.fillable (Ct8 name orig a b c d e f g h) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  let e = (Term.fillable e sub)
  let f = (Term.fillable f sub)
  let g = (Term.fillable g sub)
  let h = (Term.fillable h sub)
  (Bool.or a (Bool.or b (Bool.or c (Bool.or d (Bool.or e (Bool.or f (Bool.or g h)))))))

(Term.fillable (Fn0 name orig) sub) =
  False

(Term.fillable (Fn1 name orig a) sub) =
  let a = (Term.fillable a sub)
  a

(Term.fillable (Fn2 name orig a b) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  (Bool.or a b)

(Term.fillable (Fn3 name orig a b c) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  (Bool.or a (Bool.or b c))

(Term.fillable (Fn4 name orig a b c d) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  (Bool.or a (Bool.or b (Bool.or c d)))

(Term.fillable (Fn5 name orig a b c d e) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  let e = (Term.fillable e sub)
  (Bool.or a (Bool.or b (Bool.or c (Bool.or d e))))

(Term.fillable (Fn6 name orig a b c d e f) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  let e = (Term.fillable e sub)
  let f = (Term.fillable f sub)
  (Bool.or a (Bool.or b (Bool.or c (Bool.or d (Bool.or e f)))))

(Term.fillable (Fn7 name orig a b c d e f g) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  let e = (Term.fillable e sub)
  let f = (Term.fillable f sub)
  let g = (Term.fillable g sub)
  (Bool.or a (Bool.or b (Bool.or c (Bool.or d (Bool.or e (Bool.or f g))))))

(Term.fillable (Fn8 name orig a b c d e f g h) sub) =
  let a = (Term.fillable a sub)
  let b = (Term.fillable b sub)
  let c = (Term.fillable c sub)
  let d = (Term.fillable d sub)
  let e = (Term.fillable e sub)
  let f = (Term.fillable f sub)
  let g = (Term.fillable g sub)
  let h = (Term.fillable h sub)
  (Bool.or a (Bool.or b (Bool.or c (Bool.or d (Bool.or e (Bool.or f (Bool.or g h)))))))

(Term.fillable (Hlp orig) sub) =
  False

(Term.fillable (U60 orig) sub) =
  False

(Term.fillable (Num orig numb) sub) =
  False

(Term.fillable (Op2 orig oper val0 val1) sub) =
  let val0 = (Term.fillable val0 sub)
  let val1 = (Term.fillable val1 sub)
  (Bool.or val0 val1)

(Term.fillable (Hol orig numb) sub) =
  (Maybe.case (Subst.look sub numb) False λval(True))

// Term.fill Term Subst : (Pair Term Bool)
// ---------------------------------------

(Term.fill term End)                            = term
(Term.fill (Typ orig) sub)                      = (Typ orig)
(Term.fill (Var orig name index) sub)           = (Var orig name index)
(Term.fill (All orig name type body) sub)       = (All orig name (Term.fill type sub) λx (Term.fill (body x) sub))
(Term.fill (Lam orig name body) sub)            = (Lam orig name λx (Term.fill (body x) sub))
(Term.fill (App orig func argm) sub)            = (APP orig (Term.fill func sub) (Term.fill argm sub))
(Term.fill (Let orig name expr body) sub)       = (LET orig name (Term.fill expr sub) λx (Term.fill (body x) sub))
(Term.fill (Ann orig expr type) sub)            = (ANN orig (Term.fill expr sub) (Term.fill type sub))
(Term.fill (Ct0 name orig) sub)                 = (Ct0 name orig)
(Term.fill (Ct1 name orig a) sub)               = (Ct1 name orig (Term.fill a sub))
(Term.fill (Ct2 name orig a b) sub)             = (Ct2 name orig (Term.fill a sub) (Term.fill b sub))
(Term.fill (Ct3 name orig a b c) sub)           = (Ct3 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub))
(Term.fill (Ct4 name orig a b c d) sub)         = (Ct4 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub))
(Term.fill (Ct5 name orig a b c d e) sub)       = (Ct5 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub) (Term.fill e sub))
(Term.fill (Ct6 name orig a b c d e f) sub)     = (Ct6 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub) (Term.fill e sub) (Term.fill f sub))
(Term.fill (Ct7 name orig a b c d e f g) sub)   = (Ct7 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub) (Term.fill e sub) (Term.fill f sub) (Term.fill g sub))
(Term.fill (Ct8 name orig a b c d e f g h) sub) = (Ct8 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub) (Term.fill e sub) (Term.fill f sub) (Term.fill g sub) (Term.fill h sub))
(Term.fill (Fn0 name orig) sub)                 = (FN0 name orig)
(Term.fill (Fn1 name orig a) sub)               = (FN1 name orig (Term.fill a sub))
(Term.fill (Fn2 name orig a b) sub)             = (FN2 name orig (Term.fill a sub) (Term.fill b sub))
(Term.fill (Fn3 name orig a b c) sub)           = (FN3 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub))
(Term.fill (Fn4 name orig a b c d) sub)         = (FN4 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub))
(Term.fill (Fn5 name orig a b c d e) sub)       = (FN5 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub) (Term.fill e sub))
(Term.fill (Fn6 name orig a b c d e f) sub)     = (FN6 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub) (Term.fill e sub) (Term.fill f sub))
(Term.fill (Fn7 name orig a b c d e f g) sub)   = (FN7 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub) (Term.fill e sub) (Term.fill f sub) (Term.fill g sub))
(Term.fill (Fn8 name orig a b c d e f g h) sub) = (FN8 name orig (Term.fill a sub) (Term.fill b sub) (Term.fill c sub) (Term.fill d sub) (Term.fill e sub) (Term.fill f sub) (Term.fill g sub) (Term.fill h sub))
(Term.fill (Hlp orig) sub)                      = (Hlp orig)
(Term.fill (U60 orig) sub)                      = (U60 orig)
(Term.fill (Num orig numb) sub)                 = (Num orig numb)
(Term.fill (Op2 orig oper val0 val1) sub)       = (OP2 orig oper (Term.fill val0 sub) (Term.fill val1 sub))
(Term.fill (Hol orig numb) sub)                 = (Maybe.case (Subst.look sub numb) (Hol orig numb) λval (Term.fill val sub))

// Eval Term (List Term) : Term
// ----------------------------

(Eval (Typ orig))                              = (Typ orig)
(Eval (Var orig name index))                   = (Var orig name index)
(Eval (Hol orig numb))                         = (Hol orig numb)
(Eval (All orig name type body))               = (All orig name (Eval type) λx (Eval (body x)))
(Eval (Lam orig name body))                    = (Lam orig name λx (Eval (body x)))
(Eval (Let orig name expr body))               = (LET orig name (Eval expr) λx (Eval (body x)))
(Eval (Ann orig expr typ))                     = (ANN orig (Eval expr) (Eval typ))
(Eval (App orig func argm))                    = (APP orig (Eval func) (Eval argm))
(Eval (Ct0 ctid orig))                         = (Ct0 ctid orig)
(Eval (Ct1 ctid orig x0))                      = (Ct1 ctid orig (Eval x0))
(Eval (Ct2 ctid orig x0 x1))                   = (Ct2 ctid orig (Eval x0) (Eval x1))
(Eval (Ct3 ctid orig x0 x1 x2))                = (Ct3 ctid orig (Eval x0) (Eval x1) (Eval x2))
(Eval (Ct4 ctid orig x0 x1 x2 x3))             = (Ct4 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3))
(Eval (Ct5 ctid orig x0 x1 x2 x3 x4))          = (Ct5 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3) (Eval x4))
(Eval (Ct6 ctid orig x0 x1 x2 x3 x4 x5))       = (Ct6 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3) (Eval x4) (Eval x5))
(Eval (Ct7 ctid orig x0 x1 x2 x3 x4 x5 x6))    = (Ct7 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3) (Eval x4) (Eval x5) (Eval x6))
(Eval (Ct8 ctid orig x0 x1 x2 x3 x4 x5 x6 x7)) = (Ct8 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3) (Eval x4) (Eval x5) (Eval x6) (Eval x7))
(Eval (Fn0 ctid orig))                         = (FN0 ctid orig)
(Eval (Fn1 ctid orig x0))                      = (FN1 ctid orig (Eval x0))
(Eval (Fn2 ctid orig x0 x1))                   = (FN2 ctid orig (Eval x0) (Eval x1))
(Eval (Fn3 ctid orig x0 x1 x2))                = (FN3 ctid orig (Eval x0) (Eval x1) (Eval x2))
(Eval (Fn4 ctid orig x0 x1 x2 x3))             = (FN4 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3))
(Eval (Fn5 ctid orig x0 x1 x2 x3 x4))          = (FN5 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3) (Eval x4))
(Eval (Fn6 ctid orig x0 x1 x2 x3 x4 x5))       = (FN6 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3) (Eval x4) (Eval x5))
(Eval (Fn7 ctid orig x0 x1 x2 x3 x4 x5 x6))    = (FN7 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3) (Eval x4) (Eval x5) (Eval x6))
(Eval (Fn8 ctid orig x0 x1 x2 x3 x4 x5 x6 x7)) = (FN8 ctid orig (Eval x0) (Eval x1) (Eval x2) (Eval x3) (Eval x4) (Eval x5) (Eval x6) (Eval x7))
(Eval (Hlp orig))                              = (Hlp orig)
(Eval (U60 orig))                              = (U60 orig)
(Eval (Num orig numb))                         = (Num orig numb)
(Eval (Op2 orig oper val0 val1))               = (OP2 orig oper (Eval val0) (Eval val1))

// Equal Term Term : (Checker Bool)
// --------------------------------

// Typ equality
(Equal (Typ orig) (Typ orig)) =
  (Checker.done True)

// All equality
(Equal (All a.orig a.name a.type a.body) (All b.orig b.name b.type b.body)) =
  ask dep  = (Checker.bind Checker.get_depth)
  ask type = (Checker.bind (Equal a.type b.type))
  ask body = (Checker.bind (Checker.extended (Equal (a.body (Var a.orig a.name dep)) (b.body (Var b.orig b.name dep))) Null Null []))
  (Checker.done (Bool.and type body))

// Lam equality
(Equal (Lam a.orig a.name a.body) (Lam b.orig b.name b.body)) =
  ask dep  = (Checker.bind Checker.get_depth)
  ask body = (Checker.bind (Checker.extended (Equal (a.body (Var a.orig a.name dep)) (b.body (Var b.orig b.name dep))) Null Null []))
  (Checker.done body)

// App equality
(Equal (App a.orig a.func a.argm) (App b.orig b.func b.argm)) =
  ask func = (Checker.bind (Equal a.func b.func))
  ask argm = (Checker.bind (Equal a.argm b.argm))
  (Checker.done (Bool.and func argm))

// Let equality
(Equal (Let a.orig a.name a.expr a.body) (Let b.orig b.name b.expr b.body)) =
  ask dep  = (Checker.bind Checker.get_depth)
  ask expr = (Checker.bind (Equal a.expr b.expr))
  ask body = (Checker.bind (Checker.extended (Equal (a.body (Var a.orig a.name dep)) (b.body (Var b.orig b.name dep))) Null Null []))
  (Checker.done (Bool.and expr body))

// Ann equality
(Equal (Ann a.orig a.expr a.type) (Ann b.orig b.expr b.type)) =
  ask expr = (Checker.bind (Equal a.expr b.expr))
  ask type = (Checker.bind (Equal a.type b.type))
  (Checker.done (Bool.and expr type))

// Ct0 equality
(Equal (Ct0 a.ctid a.orig) (Ct0 b.ctid b.orig)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  (Checker.done ctid)

// Ct1 equality
(Equal (Ct1 a.ctid a.orig a.x0) (Ct1 b.ctid b.orig b.x0)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  (Checker.done (Bool.and ctid x0))

// Ct2 equality
(Equal (Ct2 a.ctid a.orig a.x0 a.x1) (Ct2 b.ctid b.orig b.x0 b.x1)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  (Checker.done (Bool.and ctid (Bool.and x0 x1)))

// Ct3 equality
(Equal (Ct3 a.ctid a.orig a.x0 a.x1 a.x2) (Ct3 b.ctid b.orig b.x0 b.x1 b.x2)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 x2))))

// Ct4 equality
(Equal (Ct4 a.ctid a.orig a.x0 a.x1 a.x2 a.x3) (Ct4 b.ctid b.orig b.x0 b.x1 b.x2 b.x3)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 x3)))))

// Ct5 equality
(Equal (Ct5 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4) (Ct5 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  ask x4   = (Checker.bind (Equal a.x4 b.x4))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 x4))))))

// Ct6 equality
(Equal (Ct6 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5) (Ct6 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  ask x4   = (Checker.bind (Equal a.x4 b.x4))
  ask x5   = (Checker.bind (Equal a.x5 b.x5))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 x5)))))))

// Ct7 equality
(Equal (Ct7 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5 a.x6) (Ct7 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5 b.x6)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  ask x4   = (Checker.bind (Equal a.x4 b.x4))
  ask x5   = (Checker.bind (Equal a.x5 b.x5))
  ask x6   = (Checker.bind (Equal a.x6 b.x6))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 (Bool.and x5 x6))))))))

// Ct8 equality
(Equal (Ct8 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5 a.x6 a.x7) (Ct8 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5 b.x6 b.x7)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  ask x4   = (Checker.bind (Equal a.x4 b.x4))
  ask x5   = (Checker.bind (Equal a.x5 b.x5))
  ask x6   = (Checker.bind (Equal a.x6 b.x6))
  ask x7   = (Checker.bind (Equal a.x7 b.x7))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 (Bool.and x5 (Bool.and x6 x7)))))))))

// Fn0 equality
(Equal (Fn0 a.ctid a.orig) (Fn0 b.ctid b.orig)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  (Checker.done ctid)

// Fn1 equality
(Equal (Fn1 a.ctid a.orig a.x0) (Fn1 b.ctid b.orig b.x0)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  (Checker.done (Bool.and ctid x0))

// Fn2 equality
(Equal (Fn2 a.ctid a.orig a.x0 a.x1) (Fn2 b.ctid b.orig b.x0 b.x1)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  (Checker.done (Bool.and ctid (Bool.and x0 x1)))

// Fn3 equality
(Equal (Fn3 a.ctid a.orig a.x0 a.x1 a.x2) (Fn3 b.ctid b.orig b.x0 b.x1 b.x2)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 x2))))

// Fn4 equality
(Equal (Fn4 a.ctid a.orig a.x0 a.x1 a.x2 a.x3) (Fn4 b.ctid b.orig b.x0 b.x1 b.x2 b.x3)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 x3)))))

// Fn5 equality
(Equal (Fn5 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4) (Fn5 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  ask x4   = (Checker.bind (Equal a.x4 b.x4))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 x4))))))

// Fn6 equality
(Equal (Fn6 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5) (Fn6 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  ask x4   = (Checker.bind (Equal a.x4 b.x4))
  ask x5   = (Checker.bind (Equal a.x5 b.x5))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 x5)))))))

// Fn7 equality
(Equal (Fn7 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5 a.x6) (Fn7 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5 b.x6)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  ask x4   = (Checker.bind (Equal a.x4 b.x4))
  ask x5   = (Checker.bind (Equal a.x5 b.x5))
  ask x6   = (Checker.bind (Equal a.x6 b.x6))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 (Bool.and x5 x6))))))))

// Fn8 equality
(Equal (Fn8 a.ctid a.orig a.x0 a.x1 a.x2 a.x3 a.x4 a.x5 a.x6 a.x7) (Fn8 b.ctid b.orig b.x0 b.x1 b.x2 b.x3 b.x4 b.x5 b.x6 b.x7)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask x0   = (Checker.bind (Equal a.x0 b.x0))
  ask x1   = (Checker.bind (Equal a.x1 b.x1))
  ask x2   = (Checker.bind (Equal a.x2 b.x2))
  ask x3   = (Checker.bind (Equal a.x3 b.x3))
  ask x4   = (Checker.bind (Equal a.x4 b.x4))
  ask x5   = (Checker.bind (Equal a.x5 b.x5))
  ask x6   = (Checker.bind (Equal a.x6 b.x6))
  ask x7   = (Checker.bind (Equal a.x7 b.x7))
  (Checker.done (Bool.and ctid (Bool.and x0 (Bool.and x1 (Bool.and x2 (Bool.and x3 (Bool.and x4 (Bool.and x5 (Bool.and x6 x7)))))))))

// U60 equality
(Equal (U60 a.orig) (U60 b.orig)) =
  (Checker.done True)

// Num equality
(Equal (Num a.orig a.numb) (Num b.orig b.numb)) =
  (Checker.done (U60.equal a.numb b.numb))

// Op2 equality
(Equal (Op2 a.orig a.oper a.val0 a.val1) (Op2 b.orig b.oper b.val0 b.val1)) =
  ask val0 = (Checker.bind (Equal a.val0 b.val0))
  ask val1 = (Checker.bind (Equal a.val1 b.val1))
  (Checker.done (Bool.and val0 val1))

// Hlp equality
(Equal (Hlp a.orig) b) =
  (Checker.done True)

// Hlp equality
(Equal a (Hlp b.orig)) =
  (Checker.done True)

// Hol equality #0
(Equal (Hol a.orig a.numb) b) =
  (Equal.hol a.orig a.numb b)

// Hol equality #1
(Equal a (Hol b.orig b.numb)) =
  (Equal.hol b.orig b.numb a)

// Var equality #0
(Equal (Var a.orig a.name a.index) b) =
  ask rhs = (Checker.bind (Checker.get_right_hand_side))
  (Equal.var rhs a.orig a.name a.index b)

// Var equality #1
(Equal a (Var b.orig b.name b.index)) =
  ask rhs = (Checker.bind (Checker.get_right_hand_side))
  (Equal.var rhs b.orig b.name b.index a)

// Not equal
(Equal a b) =
  ask sub = (Checker.bind Checker.get_subst)
  (Bool.if (Bool.or (Term.fillable a sub) (Term.fillable b sub))
    (Equal (Term.fill a sub) (Term.fill b sub))
    (Checker.done False))

// Equal.var (rhs: Bool) (origin: U60) (index: U60) (b: Term) : (Checker bool)
// ---------------------------------------------------------------------------
// A variable is equal to a term when any of its reductions is

// If on LHS, extend the variable's equality list
// If on RHS, check if a and b are equal

// Variable checker
(Equal.var False a.orig a.name a.index b) =
  ask (Checker.bind (Checker.add_value a.index b))
  (Checker.done True)
(Equal.var True a.orig a.name a.index (Var b.orig b.name b.index)) =
  (Bool.if (U60.equal a.index b.index)
    (Checker.done True)
    ask a.val = (Checker.bind (Checker.find a.index [] λnλtλv(v)))
    ask b.val = (Checker.bind (Checker.find b.index [] λnλtλv(v)))
    ask a.chk = (Checker.bind (Equal.var.try_values a.val (Var b.orig b.name b.index)))
    ask b.chk = (Checker.bind (Equal.var.try_values b.val (Var a.orig a.name a.index)))
    (Checker.done (Bool.or a.chk b.chk)))
(Equal.var True a.orig a.name a.index b) =
  ask sub = (Checker.bind Checker.get_subst)
  (Bool.if (Term.fillable b sub)
    (Equal (Var a.orig a.name a.index) (Term.fill b sub))
    ask a.val = (Checker.bind (Checker.find a.index [] λnλtλv(v)))
    (Equal.var.try_values a.val b))

// Checks if any of a set of reductions is equal
(Equal.var.try_values (List.cons a as) b) =
  ask head = (Checker.bind (Equal a b))
  (Bool.if head
    (Checker.done True)
    (Equal.var.try_values as b))
(Equal.var.try_values List.nil b) =
  (Checker.done False)

// Equal.hol (origin: U60) (numb: U60) (b: Term) : (Checker bool)
// --------------------------------------------------------------

// Hole checker
(Equal.hol a.orig a.numb b) =
  ask got = (Checker.bind (Checker.look a.numb))
  (Equal.hol.val got a.orig a.numb b)

// Hole has no value yet, so we set it
(Equal.hol.val None a.orig a.numb b) =
  ask (Checker.bind (Checker.fill a.numb b))
  (Checker.done True)

// Hole has a value, so we compare it
(Equal.hol.val (Some a.val) a.orig a.numb b) =
  (Equal a.val b)

// Infer Term : (Checker Term)
// ---------------------------

// Infers Var
(Infer (Var orig name index)) =
  ask got_type = (Checker.bind (Checker.find index None λnλtλv(Some t)))
  (Maybe.case got_type
    ask ctx = (Checker.bind Checker.get_context)
    (Checker.fail (UnboundVariable ctx orig))
    λvar_type (Checker.done var_type))

// Infers Hol
(Infer (Hol orig numb)) =
  ask ctx = (Checker.bind Checker.get_context)
  (Checker.fail (CantInferHole ctx orig))

// Infers Typ
(Infer (Typ orig)) =
  (Checker.done (Typ orig))

// Infers All
(Infer (All orig name type body)) =
  ask dep      = (Checker.bind Checker.get_depth)
  ask type_chk = (Checker.bind (Check type (Typ orig)))
  ask body_chk = (Checker.bind (Checker.extended (Check (body (Var orig name dep)) (Typ orig)) name type []))
  (Checker.done (Typ orig))

// Infers Lam
(Infer (Lam orig name body)) =
  ask ctx = (Checker.bind Checker.get_context)
  (Checker.fail (CantInferLambda ctx orig))

// Infers App
(Infer (App orig func argm)) =
  ask sub      = (Checker.bind Checker.get_subst)
  ask func_typ = (Checker.bind (Infer func))
  (Term.if_all func_typ
    // then
    λfunc_typ_orig λfunc_typ_name λfunc_typ_type λfunc_typ_body
      ask argm_ok = (Checker.bind (Check argm func_typ_type))
      (Checker.done (func_typ_body (Eval argm)))
    // else
    ask ctx = (Checker.bind Checker.get_context)
    (Checker.fail (InvalidCall ctx orig)))

// Infers Let
(Infer (Let orig name expr body)) =
  ask dep      = (Checker.bind Checker.get_depth)
  ask expr_typ = (Checker.bind (Infer expr))
  ask body_typ = (Checker.bind (Checker.extended (Infer (body (Var orig name dep))) name expr_typ [(Eval expr)]))
  (Checker.done body_typ)

// Infers Ann
(Infer (Ann orig expr type)) =
  ask expr_chk = (Checker.bind (Check expr (Eval type)))
  (Checker.done type)

// Infers Ct0
(Infer (Ct0 ctid orig)) =
  (Checker.done (TypeOf ctid))

// Infers Ct1
(Infer (Ct1 ctid orig x0)) =
  (Infer (App orig (Ct0 ctid orig) x0))

// Infers Ct2
(Infer (Ct2 ctid orig x0 x1)) =
  (Infer (App orig (App orig (Ct0 ctid orig) x0) x1))

// Infers Ct3
(Infer (Ct3 ctid orig x0 x1 x2)) =
  (Infer (App orig (App orig (App orig (Ct0 ctid orig) x0) x1) x2))

// Infers Ct4
(Infer (Ct4 ctid orig x0 x1 x2 x3)) =
  (Infer (App orig (App orig (App orig (App orig (Ct0 ctid orig) x0) x1) x2) x3))

// Infers Ct5
(Infer (Ct5 ctid orig x0 x1 x2 x3 x4)) =
  (Infer (App orig (App orig (App orig (App orig (App orig (Ct0 ctid orig) x0) x1) x2) x3) x4))

// Infers Ct6
(Infer (Ct6 ctid orig x0 x1 x2 x3 x4 x5)) =
  (Infer (App orig (App orig (App orig (App orig (App orig (App orig (Ct0 ctid orig) x0) x1) x2) x3) x4) x5))

// Infers Ct7
(Infer (Ct7 ctid orig x0 x1 x2 x3 x4 x5 x6)) =
  (Infer (App orig (App orig (App orig (App orig (App orig (App orig (App orig (Ct0 ctid orig) x0) x1) x2) x3) x4) x5) x6))

// Infers Ct8
(Infer (Ct8 ctid orig x0 x1 x2 x3 x4 x5 x6 x7)) =
  (Infer (App orig (App orig (App orig (App orig (App orig (App orig (App orig (App orig (Ct0 ctid orig) x0) x1) x2) x3) x4) x5) x6) x7))

// Infers Fn0
(Infer (Fn0 ctid orig)) =
  (Checker.done (TypeOf ctid))

// Infers Fn1
(Infer (Fn1 ctid orig x0)) =
  (Infer (App orig (Fn0 ctid orig) x0))

// Infers Fn2
(Infer (Fn2 ctid orig x0 x1)) =
  (Infer (App orig (App orig (Fn0 ctid orig) x0) x1))

// Infers Fn3
(Infer (Fn3 ctid orig x0 x1 x2)) =
  (Infer (App orig (App orig (App orig (Fn0 ctid orig) x0) x1) x2))

// Infers Fn4
(Infer (Fn4 ctid orig x0 x1 x2 x3)) =
  (Infer (App orig (App orig (App orig (App orig (Fn0 ctid orig) x0) x1) x2) x3))

// Infers Fn5
(Infer (Fn5 ctid orig x0 x1 x2 x3 x4)) =
  (Infer (App orig (App orig (App orig (App orig (App orig (Fn0 ctid orig) x0) x1) x2) x3) x4))

// Infers Fn6
(Infer (Fn6 ctid orig x0 x1 x2 x3 x4 x5)) =
  (Infer (App orig (App orig (App orig (App orig (App orig (App orig (Fn0 ctid orig) x0) x1) x2) x3) x4) x5))

// Infers Fn7
(Infer (Fn7 ctid orig x0 x1 x2 x3 x4 x5 x6)) =
  (Infer (App orig (App orig (App orig (App orig (App orig (App orig (App orig (Fn0 ctid orig) x0) x1) x2) x3) x4) x5) x6))

// Infers Fn8
(Infer (Fn8 ctid orig x0 x1 x2 x3 x4 x5 x6 x7)) =
  (Infer (App orig (App orig (App orig (App orig (App orig (App orig (App orig (App orig (Fn0 ctid orig) x0) x1) x2) x3) x4) x5) x6) x7))

// Infers Hlp
(Infer (Hlp orig)) =
  ask ctx = (Checker.bind (Checker.get_context))
  (Checker.fail (Inspection ctx orig (Hlp 0)))

// Infers U60
(Infer (U60 orig)) =
  (Checker.done (Typ 0))

// Infers Num
(Infer (Num orig numb)) =
  (Checker.done (U60 0))

// Infers Op2
(Infer (Op2 orig oper val0 val1)) =
  ask val0_chk = (Checker.bind (Check val0 (U60 0)))
  ask val1_chk = (Checker.bind (Check val1 (U60 0)))
  (Checker.done (U60 0))

// Check Term Term : (Checker Unit)
// --------------------------------

// Checks Lam 
(Check (Lam orig name body) type) =
  ask sub = (Checker.bind Checker.get_subst)
  ((Term.if_all type
    λt_orig λt_name λt_type λt_body λorig λname λbody
      ask dep      = (Checker.bind Checker.get_depth)
      ask body_chk = (Checker.bind (Checker.extended (Check (body (Var orig name dep)) (t_body (Var t_orig t_name dep))) name t_type []))
      (Checker.done Unit.new)
    λorig λname λbody
      ask ctx = (Checker.bind Checker.get_context)
      (Checker.fail (CantInferLambda ctx orig)))
    orig name body)

// Checks Let
(Check (Let orig name expr body) type) =
  ask dep      = (Checker.bind Checker.get_depth)
  ask expr_typ = (Checker.bind (Infer expr))
  ask body_chk = (Checker.bind (Checker.extended (Check (body (Var orig name dep)) type) name expr_typ [(Eval expr)]))
  (Checker.done Unit.new)

// Infers Hlp
(Check (Hlp orig) type) =
  ask ctx = (Checker.bind (Checker.get_context))
  ask (Checker.bind (Checker.error Unit.new (Inspection ctx orig type)))
  (Checker.done type)

// Checks Var
(Check (Var orig name index) type) =
  ask rhs = (Checker.bind Checker.get_right_hand_side)
  (Bool.if rhs
    (Check.compare rhs (Var orig name index) type)
    (Checker.extend name type List.nil))

// Checks Hol
(Check (Hol orig numb) type) =
  (Checker.done Unit.new)

// Checks others
(Check term type) =
  ask rhs = (Checker.bind Checker.get_right_hand_side)
  (Check.compare rhs term type)

// Compares two terms for equality
(Check.compare rhs term type) =
  (Term.get_origin term @orig @term
    ask term_typ = (Checker.bind (Infer term))
    ((Bool.if rhs
      @term_typ @type
        (Checker.new_equation orig type term_typ)
      @term_typ @type
        ask is_equal = (Checker.bind (Equal (Eval term_typ) (Eval type)))
        (Bool.if is_equal
          (Checker.done Unit.new)
          ask ctx = (Checker.bind Checker.get_context)
          (Checker.fail (ImpossibleCase ctx orig type term_typ)))) // impossible case
      term_typ type))

// Check.rule Rule (List Term) : (Checker Unit)
// --------------------------------------------------

(Check.rule (LHS arg args) (All orig name type body)) =
  ask arg_chk  = (Checker.bind (Check arg type))
  ask args_chk = (Checker.bind (Check.rule args (body arg)))
  (Checker.done Unit.new)
(Check.rule (LHS arg args) other) =
  ask ctx = (Checker.bind Checker.get_context)
  (Checker.fail (TooManyArguments ctx (Term.get_origin arg (@orig @term orig))))
(Check.rule (RHS expr) type) =
  ask (Checker.bind (Checker.set_right_hand_side True))
  ask expr_chk = (Checker.bind (Check expr type))
  (Checker.done Unit.new)

// Unify (chk: Checker Unit) : (Checker Unit)
// ------------------------------------------
// Runs a checker, then attempts to unify all equations produced

(Unify checker) =
  ask (Checker.bind checker)
  ask equations = (Checker.bind (Checker.get_equations))
  (Unify.go equations List.nil False)

// Attempts to unify a list of equations repeatedly
// Unify.go (eqts: List Equations) (rems: List Equations) (changed: Bool) : Checker Unit
(Unify.go List.nil List.nil changed) = (Checker.done Unit.new)
(Unify.go List.nil unsolved True)    = (Unify.go unsolved List.nil False)
(Unify.go List.nil unsolved False)   = (Unify.go.fail unsolved)
(Unify.go (List.cons (Equation ctx orig a b) equations) unsolved changed) =
  ask is_equal = (Checker.bind (Equal (Eval a) (Eval b)))
  ((Bool.if is_equal
    @eqt @uns (Unify.go eqt uns True)
    @eqt @uns (Unify.go eqt (List.cons (Equation ctx orig a b) uns) changed)
  ) equations unsolved)

// Throws a TypeMismatch error for every equation in a list
// Unify.fail (eqts: List Equations) : (Checker Unit)
(Unify.go.fail List.nil) = (Checker.done Unit.new)
(Unify.go.fail (List.cons (Equation ctx orig a b) eqts)) =
  ask (Checker.bind (Checker.error Unit.new (TypeMismatch ctx orig a b)))
  (Unify.go.fail eqts)

// APP U60 Term Term : Term
// ------------------------

(APP orig (Lam orig name fbody) argm) = (fbody argm)
(APP orig func                  argm) = (App orig func argm)

// LET U60 Name Term Term : Term
// -----------------------------

(LET orig name expr body) = (body expr)

// ANN U60 Term Term : Term
// -------------------------

(ANN orig expr type) = expr

// OP2 U60 Term Term : Term
// ------------------------

(OP2 orig ADD  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (+  a.numb b.numb))
(OP2 orig SUB  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (-  a.numb b.numb))
(OP2 orig MUL  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (*  a.numb b.numb))
(OP2 orig DIV  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (/  a.numb b.numb))
(OP2 orig MOD  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (%  a.numb b.numb))
(OP2 orig AND  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (&  a.numb b.numb))
(OP2 orig OR   (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (|  a.numb b.numb))
(OP2 orig XOR  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (^  a.numb b.numb))
(OP2 orig SHL  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (<< a.numb b.numb))
(OP2 orig SHR  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (>> a.numb b.numb))
(OP2 orig LTN  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (<  a.numb b.numb))
(OP2 orig LTE  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (<= a.numb b.numb))
(OP2 orig EQL  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (== a.numb b.numb))
(OP2 orig GTE  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (>= a.numb b.numb))
(OP2 orig GTN  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (>  a.numb b.numb))
(OP2 orig NEQ  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (!= a.numb b.numb))
(OP2 orig oper val0                val1)                = (Op2 orig oper val0 val1)

// Stringification
// ---------------

// FIXME: show is quadratic; must improve

(Show term) =
  let sugars = [
    (Show.sugar.string term)
    (Show.sugar.list term)
    (Show.sugar.sigma term)
  ]
  (Maybe.try sugars (Show.go term))

(Show.go (Var orig name index)) = (Text [
  (Show.name name)
])

(Show.go (Hol orig numb)) = (Text [
  "_"
])

(Show.go (Typ orig)) = (Text [
  "Type"
])

// TODO: omit unecessary parenthesis
(Show.go (All orig name type body)) =
  (U60.if (== name 63) // underscore
    (Text [
      "((" (Show type) ") -> " (Show (body (Var orig name 0))) ")"
    ])
    (Text [
      "((" (Show.name name) ": " (Show type) ") -> "
      (Show (body (Var orig name 0))) ")"
    ]))

(Show.go (Lam orig name body)) =
  (Text [
    "(" (Show.name name) " => "
    (Show (body (Var orig name 0))) ")"
  ])

(Show.go (Let orig name expr body)) = (Text [
  "let " (Show.name name) " = " (Show (expr (Var orig name 0))) "; "
  (Show (body (Var orig name 0)))
])

(Show.go (Ann orig expr type)) = (Text [
  "{" (Show expr) " :: " (Show type) "}"
])

// TODO: omit unecessary parenthesis
(Show.go (App orig func argm)) = (Text [
  "("
  (Show func) " "
  (Show argm)
  ")"
])

(Show.go (Ct0 ctid orig)) = (Text [
  (NameOf ctid)
])

(Show.go (Ct1 ctid orig x0)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0)
  ")"
])

(Show.go (Ct2 ctid orig x0 x1)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1)
  ")"
])

(Show.go (Ct3 ctid orig x0 x1 x2)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2)
  ")"
])

(Show.go (Ct4 ctid orig x0 x1 x2 x3)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3)
  ")"
])

(Show.go (Ct5 ctid orig x0 x1 x2 x3 x4)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3) " "
  (Show x4)
  ")"
])

(Show.go (Ct6 ctid orig x0 x1 x2 x3 x4 x5)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3) " "
  (Show x4) " "
  (Show x5)
  ")"
])

(Show.go (Ct7 ctid orig x0 x1 x2 x3 x4 x5 x6)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3) " "
  (Show x4) " "
  (Show x5) " "
  (Show x6)
  ")"
])

(Show.go (Ct8 ctid orig x0 x1 x2 x3 x4 x5 x6 x7)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3) " "
  (Show x4) " "
  (Show x5) " "
  (Show x6) " "
  (Show x7)
  ")"
])

(Show.go (Fn0 ctid orig)) = (Text [
  (NameOf ctid)
])

(Show.go (Fn1 ctid orig x0)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0)
  ")"
])

(Show.go (Fn2 ctid orig x0 x1)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1)
  ")"
])

(Show.go (Fn3 ctid orig x0 x1 x2)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2)
  ")"
])

(Show.go (Fn4 ctid orig x0 x1 x2 x3)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3)
  ")"
])

(Show.go (Fn5 ctid orig x0 x1 x2 x3 x4)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3) " "
  (Show x4)
  ")"
])

(Show.go (Fn6 ctid orig x0 x1 x2 x3 x4 x5)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3) " "
  (Show x4) " "
  (Show x5)
  ")"
])

(Show.go (Fn7 ctid orig x0 x1 x2 x3 x4 x5 x6)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3) " "
  (Show x4) " "
  (Show x5) " "
  (Show x6)
  ")"
])

(Show.go (Fn8 ctid orig x0 x1 x2 x3 x4 x5 x6 x7)) = (Text [
  "("
  (NameOf ctid) " "
  (Show x0) " "
  (Show x1) " "
  (Show x2) " "
  (Show x3) " "
  (Show x4) " "
  (Show x5) " "
  (Show x6) " "
  (Show x7)
  ")"
])

(Show.go (Hlp orig)) =
  (Text [
    "?"
  ])

(Show.go (U60 orig)) =
  (Text [
    "U60"
  ])

(Show.go (Num orig numb)) =
  (Text [
    (Show.u60 numb)
  ])

(Show.go (Op2 orig oper val0 val1)) =
  (Text [
    "(" (Show.oper oper) " " (Show val0) " " (Show val1) ")"
  ])

(Show.sugar.string term) =
  ask text = (Maybe.bind (Show.sugar.string.go term))
  let quot = (String.cons '"' String.nil)
  (Some (Text [quot text quot]))
(Show.sugar.string.go (Ct2 String.cons. orig (Num n.orig n.numb) tail)) = 
  ask tail = (Maybe.bind (Show.sugar.string.go tail))
  (Some (String.cons n.numb tail))
(Show.sugar.string.go (Ct0 String.nil. orig)) = (Some (String.nil))
(Show.sugar.string.go rest) = None

(Show.sugar.list term) =
  ask vals = (Maybe.bind (Show.sugar.list.go term))
  let open = "["
  let vals = (List.join vals " ")
  let clos = "]"
  (Some (Text [open vals clos]))
(Show.sugar.list.go (Ct3 List.cons. orig t head tail)) =
  let head = (Show head)
  ask tail = (Maybe.bind (Show.sugar.list.go tail))
  (Some (List.cons head tail))
(Show.sugar.list.go (Ct1 List.nil. orig t)) =
  (Some List.nil)
(Show.sugar.list.go other) =
  None

(Show.sugar.sigma (Ct2 Sigma. orig type (Lam orig_ name body))) =
  (Some (Text [
    "(["
    (Show.name name)
    ": "
    (Show type)
    "] -> "
    (Show (body (Var orig_ name 0)))
    ")"
  ]))
(Show.sugar.sigma other) =
  None

(Show.oper ADD) = "+"
(Show.oper SUB) = "-"
(Show.oper MUL) = "*"
(Show.oper DIV) = "/"
(Show.oper MOD) = "%"
(Show.oper AND) = "&"
(Show.oper OR)  = "|"
(Show.oper XOR) = "^"
(Show.oper SHL) = "<<"
(Show.oper SHR) = ">>"
(Show.oper LNT) = "<"
(Show.oper LTE) = "<="
(Show.oper EQL) = "=="
(Show.oper GTE) = ">="
(Show.oper GTN) = ">"
(Show.oper NEQ) = "!="
(Show.oper op)  = "?"

(Show.context ctx sub) =
  (Show.context.go ctx sub (Context.max_name_length ctx))

(Show.context.go Empty sub pad) = String.nil
(Show.context.go (Entry name type vals rest) sub pad) = (Text [
  (Show.context.type name type sub pad)
  (Show.context.vals name vals sub pad)
  (Show.context.go rest sub pad)
])

(Show.context.type name type sub pad) = (Text [
  "- " (String.pad_right (Show.name name) ' ' pad) " : " (String.cut (Show (Term.fill type sub))) Line
])

(Show.context.vals name List.nil sub pad) = String.nil
(Show.context.vals name (List.cons val vals) sub pad) = (Text [
  (Color "2") "- " (String.pad_right (Show.name name) ' ' pad) " = " (String.cut (Show (Term.fill val sub))) (Color "0") Line
  (Show.context.vals name vals sub pad)
])

(Show.subst End) = "|"
(Show.subst (Unf rest)) = (Text [
  "~ ?" Line
  (Show.subst rest)
])
(Show.subst (Sub expr rest)) = (Text [
  "~ " (Show expr) Line
  (Show.subst rest)
])

// Show.u60 U60 : String
(Show.u60 n) = (Show.u60.build n String.nil)
  (Show.u60.build n str) = 
    let next = (String.cons (+ 48 (% n 10)) str)
    ((U60.if (< n 10) λx(x) λx(Show.u60.build (/ n 10) x)) next)

// Show.name U60 : String
(Show.name name) = (Show.name.go name String.nil)

// Show.name.go U60 String : String
(Show.name.go name chrs) =
  (U60.if (== name 0) chrs
    let val = (% name 64)
    let chr =
      (U60.if (== val 0) '.'
      (U60.if (& (<=  1 val) (<= val 10)) (+ (- val  1) '0')
      (U60.if (& (<= 11 val) (<= val 36)) (+ (- val 11) 'A')
      (U60.if (& (<= 37 val) (<= val 62)) (+ (- val 37) 'a')
      (U60.if (== val 63) '_' '?')))))
    (Show.name.go (/ name 64) (String.cons chr chrs)))

// API
// ---

// Checks all the functions on the "Functions" list and outputs the results
API.check_all =
  let output = (API.output (List.reverse (API.check_functions Functions)))
  (Bool.if (String.is_empty output)
    (Text [ "All terms check." Line Line ])
    output)

// Evals the main function and outputs the result
API.eval_main = (Text [
  (Show (FN0 Main. 0))
  Line Line
])

// Checks all functions in a list
// API.check_functions (fns: List FnId) : List (Pair FnId (List (Result Unit)))
(API.check_functions List.nil) = List.nil
(API.check_functions (List.cons f fs)) =
  let head = (Pair.new f (API.check_function f))
  let tail = (API.check_functions fs)
  (List.cons head tail)

// Checks a function
// API.check_function (id: FnId) : List (Result Unit)
(API.check_function func) =
  let ruls = (RuleOf func)
  let type = (TypeOf func)
  let type_check = (Checker.run (Unify (Check type (Typ 0))) True)
  let rule_check = (API.check_function.rules ruls type)
  (List.cons type_check rule_check)

// Checks a function's rules
// API.check_function.rules (List Rule) Term : List (Result Unit)
(API.check_function.rules List.nil type) = List.nil
(API.check_function.rules (List.cons rule rules) type) =
  let head = (Checker.run (Unify (Check.rule rule type)) False)
  let tail = (API.check_function.rules rules type)
  (List.cons head tail)

// Converts a list of check results to a string
// API.output (res: List (Pair FnId (Result Unit))) : String
(API.output List.nil) = String.nil
(API.output (List.cons (Pair.new fnid checks) rest)) = (Text [
  (API.output.function fnid checks)
  (API.output rest)
])

// Converts a list of check results to a string
// API.output.function (fnid: FnId) (List (Result Unit)) : String
(API.output.function fnid List.nil)                                                 = String.nil
(API.output.function fnid (List.cons (Checked ctx dep rhs sub eqt err val) checks)) = (API.output.function.show_errors err sub fnid checks)
(API.output.function fnid (List.cons (Errored ctx sub err) checks))                 = (API.output.function.show_errors err sub fnid checks)

// Shows the errors returned by a function check
// API.output (List Error) FnId (List (Result Unit)) : String
(API.output.function.show_errors List.nil             sub fnid checks) = (API.output.function fnid checks)
(API.output.function.show_errors (List.cons err errs) sub fnid checks) = (Text [
  (API.output.error fnid err sub) Line
  (API.output.function.show_errors errs sub fnid checks)
])

// Shows a specific error
// API.output.error (fnid: FnId) (err: Error) (sub: Subst) : String
(API.output.error fnid (UnboundVariable ctx orig) sub) = (Text [
  (Color "4") "Unbound Variable." (Color "0") Line
  (API.output.error.details fnid ctx sub orig)
])
(API.output.error fnid (CantInferLambda ctx orig) sub) = (Text [
  (Color "4") "Can't infer lambda." (Color "0") Line
  (API.output.error.details fnid ctx sub orig)
])
(API.output.error fnid (CantInferHole ctx orig) sub) = (Text [
  (Color "4") "Can't infer hole." (Color "0") Line
  (API.output.error.details fnid ctx sub orig)
])
(API.output.error fnid (TooManyArguments ctx orig) sub) = (Text [
  (Color "4") "Too many arguments." (Color "0") Line
  (API.output.error.details fnid ctx sub orig)
])
(API.output.error fnid (InvalidCall ctx orig) sub) = (Text [
  (Color "4") "Invalid call." (Color "0") Line
  (API.output.error.details fnid ctx sub orig)
])
(API.output.error fnid (TypeMismatch ctx orig expected detected) sub) = (Text [
  (Color "4") "Type mismatch." (Color "0") Line
  "- Expected: " (String.cut (Show (Term.fill expected sub))) Line
  "- Detected: " (String.cut (Show (Term.fill detected sub))) Line
  (API.output.error.details fnid ctx sub orig)
])
(API.output.error fnid (ImpossibleCase ctx orig expected detected) sub) = (Text [
  (Color "4") "Impossible case. You can remove it." (Color "0") Line
  //"- Expected: " (String.cut (Show (Term.fill expected sub))) Line
  //"- Detected: " (String.cut (Show (Term.fill detected sub))) Line
  (API.output.error.details fnid ctx sub orig)
])
(API.output.error fnid (Inspection ctx orig expected) sub) = (Text [
  (Color "4") "Inspection." (Color "0") Line
  "- Goal: " (String.cut (Show (Term.fill expected sub))) Line
  (API.output.error.details fnid ctx sub orig)
])

// Shows the context and location of an error
// API.output.error.details (fnid: FnId) (ctx: Context) (sub: Subst) (orig: Origin) : String
(API.output.error.details fnid ctx sub orig) = (Text [
  (Bool.if (Context.is_empty ctx) "" (Text [
    (Color "4") "Context:" (Color "0") Line
    (Show.context ctx sub)
  ]))
  (Color "4") "On '{{#F"(Show.u60 (>> orig 48))"F#}}':" (Color "0") Line
  "{{#R"(Show.u60 (>> orig 48))":"(Show.u60 (& orig 16777215))":"(Show.u60 (& (>> orig 24) 16777215))"R#}}" Line
])
  
// User-Defined Functions
// ----------------------
////INJECT////
